<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Collin Erickson" />

<meta name="date" content="2024-09-29" />

<title>Introduction to the comparer R package</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">

div.csl-bib-body { }
div.csl-entry {
clear: both;
margin-bottom: 0em;
}
.hanging div.csl-entry {
margin-left:2em;
text-indent:-2em;
}
div.csl-left-margin {
min-width:2em;
float:left;
}
div.csl-right-inline {
margin-left:2em;
padding-left:1em;
}
div.csl-indent {
margin-left: 2em;
}
</style>

<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Introduction to the comparer R package</h1>
<h4 class="author">Collin Erickson</h4>
<h4 class="date">2024-09-29</h4>



<p>When coding, especially for data science, there are multiple ways to
solve each problem. When presented with two options, you want to pick
the one that is faster and/or more accurate. Comparing different code
chunks on the same task can be tedious. It often requires creating data,
writing a for loop (or using <code>sapply</code>), then comparing.</p>
<p>The comparer package makes this comparison quick and simple:</p>
<ul>
<li><p>The same data can be given in to each model.</p></li>
<li><p>Various metrics can be used to judge results, including using the
predicted errors from the code.</p></li>
<li><p>The results are displayed in a table that allows you to quickly
judge the results.</p></li>
</ul>
<p>This document introduces the main function of the
<code>comparer</code> package, <code>mbc</code>.</p>
<div id="motivation-from-microbenchmark" class="section level2">
<h2>Motivation from <code>microbenchmark</code></h2>
<p>The R package <code>microbenchmark</code> provides the fantastic
eponymous function. It makes it simple to run different segments of code
and see which is faster. Borrowing an example from <a href="http://adv-r.had.co.nz/Performance.html" class="uri">http://adv-r.had.co.nz/Performance.html</a>, the following
shows how it gives a summary of how fast each ran.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="cf">if</span> (<span class="fu">requireNamespace</span>(<span class="st">&quot;microbenchmark&quot;</span>, <span class="at">quietly =</span> <span class="cn">TRUE</span>)) {</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>  x <span class="ot">&lt;-</span> <span class="fu">runif</span>(<span class="dv">100</span>)</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>  microbenchmark<span class="sc">::</span><span class="fu">microbenchmark</span>(<span class="fu">sqrt</span>(x), x <span class="sc">^</span> .<span class="dv">5</span>)</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>  <span class="st">&quot;microbenchmark not available on your computer&quot;</span></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>}</span></code></pre></div>
<pre><code>## Unit: nanoseconds
##     expr  min   lq mean median   uq   max neval
##  sqrt(x)  200  300  658    300  400 11900   100
##    x^0.5 2300 2500 3025   2600 2700 17100   100</code></pre>
<p>However it gives no summary of the output. For this example it is
fine since the output is deterministic, but when working with randomness
or model predictions we want to have some sort of summary or evaluation
metric to see which has better accuracy, or to just see how the outputs
differ.</p>
</div>
<div id="mbc-to-the-rescue" class="section level2">
<h2><code>mbc</code> to the rescue</h2>
<p>The function <code>mbc</code> in the <code>comparer</code> package
was created to solve this problem, where a comparison of the output is
desired in addition to the run time.</p>
<p>For example, we may wish to see how the sample size affects an
estimate of the mean of a random sample. The following shows the results
of finding the mean of 10 and 100 samples from a normal
distribution.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="fu">library</span>(comparer)</span></code></pre></div>
<pre><code>## Loading required package: GauPro</code></pre>
<pre><code>## Loading required package: mixopt</code></pre>
<pre><code>## Loading required package: dplyr</code></pre>
<pre><code>## 
## Attaching package: &#39;dplyr&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:stats&#39;:
## 
##     filter, lag</code></pre>
<pre><code>## The following objects are masked from &#39;package:base&#39;:
## 
##     intersect, setdiff, setequal, union</code></pre>
<pre><code>## Loading required package: ggplot2</code></pre>
<pre><code>## Loading required package: splitfngr</code></pre>
<pre><code>## Loading required package: numDeriv</code></pre>
<pre><code>## Loading required package: rmarkdown</code></pre>
<pre><code>## Loading required package: tidyr</code></pre>
<pre><code>## Loading required package: plyr</code></pre>
<pre><code>## ------------------------------------------------------------------------------</code></pre>
<pre><code>## You have loaded plyr after dplyr - this is likely to cause problems.
## If you need functions from both plyr and dplyr, please load plyr first, then dplyr:
## library(plyr); library(dplyr)</code></pre>
<pre><code>## ------------------------------------------------------------------------------</code></pre>
<pre><code>## 
## Attaching package: &#39;plyr&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:dplyr&#39;:
## 
##     arrange, count, desc, failwith, id, mutate, rename, summarise,
##     summarize</code></pre>
<pre><code>## Loading required package: progress</code></pre>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="fu">mbc</span>(<span class="fu">mean</span>(<span class="fu">rnorm</span>(<span class="dv">10</span>)), <span class="fu">mean</span>(<span class="fu">rnorm</span>(<span class="dv">100</span>)))</span></code></pre></div>
<pre><code>## Run times (sec)
##           Function        Sort1        Sort2        Sort3        Sort4
## 1  mean(rnorm(10)) 6.914139e-06 7.152557e-06 7.152557e-06 1.096725e-05
## 2 mean(rnorm(100)) 9.059906e-06 9.775162e-06 1.001358e-05 1.001358e-05
##          Sort5        mean           sd neval
## 1 7.970333e-04 1.65844e-04 3.528496e-04     5
## 2 2.121925e-05 1.20163e-05 5.159435e-06     5
## 
## Output summary
##               Func Stat      Sort1        Sort2       Sort3      Sort4
## 1  mean(rnorm(10))    1 -0.1385332  0.005776678  0.12611456 0.29728392
## 2 mean(rnorm(100))    1 -0.1886518 -0.071591735 -0.04465929 0.02597593
##        Sort5        mean        sd
## 1 0.56415632  0.17095965 0.2718657
## 2 0.07643412 -0.04049856 0.1012739</code></pre>
<p>By default it only runs 5 trials, but this can be changed with the
<code>times</code> parameter. The first part of the output gives the run
times. For 5 or fewer, it shows all the values in sorted order, for more
than 5 it shows summary statistics. Unfortunately, the timing is only
accurate up to 0.01 seconds, so these all show as 0.</p>
<p>The second section of the output gives the summary of the output.
This also will show summary stats for more than 5 trials, but for this
small sample size it shows all the values in sorted order with the mean
and standard deviation given. The first column shows the name of each,
and the second column shows which output statistic is given. Since there
is only one output for this code it is called “1”.</p>
<p>Setting <code>times</code> changes the number of trials run. Below
the same example as above is run but for 100 trials.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a><span class="fu">mbc</span>(<span class="fu">mean</span>(<span class="fu">rnorm</span>(<span class="dv">10</span>)), <span class="fu">mean</span>(<span class="fu">rnorm</span>(<span class="dv">100</span>)), <span class="at">times=</span><span class="dv">100</span>)</span></code></pre></div>
<pre><code>## Run times (sec)
##           Function         Min.      1st Qu.       Median         Mean
## 1  mean(rnorm(10)) 5.960464e-06 5.960464e-06 6.914139e-06 6.821156e-06
## 2 mean(rnorm(100)) 8.821487e-06 9.059906e-06 9.059906e-06 9.701252e-06
##        3rd Qu.         Max.           sd neval
## 1 6.914139e-06 1.907349e-05 1.354602e-06   100
## 2 1.001358e-05 2.098083e-05 1.495924e-06   100
## 
## Output summary
##               Func Stat       Min.     1st Qu.       Median        Mean
## 1  mean(rnorm(10))    1 -0.8159787 -0.25627116 -0.057128447 -0.01818848
## 2 mean(rnorm(100))    1 -0.1839926 -0.07144344  0.005504562  0.00882492
##      3rd Qu.      Max.        sd
## 1 0.20917428 0.7309789 0.3200503
## 2 0.07699597 0.2467896 0.1014793</code></pre>
<p>We see that the mean of both is around zero, but that the larger
sample size (<code>mean(rnorm(100))</code>) has a tighter distribution
and a standard deviation a third as large as the other, which is about
what we expect for a sample that is 10 times larger (it should be <span class="math inline">\(\sqrt{10} \approx 3.16\)</span> times smaller on
average).</p>
<p>In this example each function had its own input, but many times we
want to compare the functions on the same input for better
comparison.</p>
</div>
<div id="shared-input" class="section level2">
<h2>Shared input</h2>
<p>Input can be passed in to the <code>input</code> argument as a list,
and then the code will be evaluated in an environment with that data. In
this example we compare the functions <code>mean</code> and
<code>median</code> on random data from an exponential distribution. The
mean should be about 1, while the median should be about <span class="math inline">\(\ln(2)=0.693\)</span>.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a><span class="fu">mbc</span>(<span class="fu">mean</span>(x), <span class="fu">median</span>(x), <span class="at">input=</span><span class="fu">list</span>(<span class="at">x=</span><span class="fu">rexp</span>(<span class="dv">30</span>)))</span></code></pre></div>
<pre><code>## Run times (sec)
##    Function        Sort1        Sort2        Sort3        Sort4        Sort5
## 1   mean(x) 5.960464e-06 5.960464e-06 6.914139e-06 9.059906e-06 2.002716e-05
## 2 median(x) 2.193451e-05 2.312660e-05 2.503395e-05 2.908707e-05 1.621246e-04
##           mean           sd neval
## 1 9.584427e-06 5.973325e-06     5
## 2 5.226135e-05 6.147534e-05     5
## 
## Output summary
##        Func Stat     Sort1     Sort2     Sort3     Sort4     Sort5      mean sd
## 1   mean(x)    1 0.9596460 0.9596460 0.9596460 0.9596460 0.9596460 0.9596460  0
## 2 median(x)    1 0.6464802 0.6464802 0.6464802 0.6464802 0.6464802 0.6464802  0</code></pre>
<p>In this case each evaluation is identical since the input is not
random. The data passed to <code>input</code> is kept as is, so there is
no randomness from the data. If we want randomness in the data, we can
use <code>inputi</code>, which evaluates its argument as an expression,
meaning that each time it will be different.</p>
<p>Below is the same code as above except <code>inputi</code> is used
with <code>x</code> set in brackets instead of a list. We see there is
randomness and we can get an idea of the distribution of the median and
mean.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a><span class="fu">mbc</span>(<span class="fu">mean</span>(x), <span class="fu">median</span>(x), <span class="at">inputi=</span>{x<span class="ot">=</span><span class="fu">rexp</span>(<span class="dv">30</span>)})</span></code></pre></div>
<pre><code>## Run times (sec)
##    Function        Sort1        Sort2        Sort3        Sort4        Sort5
## 1   mean(x) 5.960464e-06 5.960464e-06 6.914139e-06 1.192093e-05 1.382828e-05
## 2 median(x) 2.598763e-05 2.694130e-05 2.694130e-05 4.291534e-05 5.197525e-05
##           mean           sd neval
## 1 8.916855e-06 3.695873e-06     5
## 2 3.495216e-05 1.185231e-05     5
## 
## Output summary
##        Func Stat        V1       V2       V3        V4        V5      mean
## 1   mean(x)    1 1.0108746 1.364529 1.057787 0.9138151 1.0079656 1.0709943
## 2 median(x)    1 0.8878218 0.742379 0.619253 0.7204445 0.7747634 0.7489323
##           sd
## 1 0.17221326
## 2 0.09699069</code></pre>
<p>When the code chunks to evaluate are simple functions of a single
variable, this can be simplified. Look how simple it is to run a test on
these!</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a><span class="fu">mbc</span>(mean, median, <span class="at">inputi=</span><span class="fu">rexp</span>(<span class="dv">30</span>))</span></code></pre></div>
<pre><code>## Run times (sec)
##   Function        Sort1        Sort2        Sort3        Sort4        Sort5
## 1     mean 1.907349e-06 2.145767e-06 2.861023e-06 3.099442e-06 4.053116e-06
## 2   median 1.907349e-06 1.907349e-06 2.145767e-06 3.099442e-06 3.099442e-06
##           mean           sd neval
## 1 2.813339e-06 8.496537e-07     5
## 2 2.431870e-06 6.171312e-07     5</code></pre>
</div>
<div id="comparing-to-expected-values" class="section level2">
<h2>Comparing to expected values</h2>
<p>The previous comparisons showed a summary of the outputs, but many
times we want to compare output values to true values, then calculate a
summary statistic, such as an average error. The argument
<code>target</code> specifies the values the code chunks should give,
then summary statistics can be calculated by specifying
<code>metrics</code>, which defaults to calculating the rmse.</p>
<p>For example, suppose we have data from a linear function, and want to
see how accurate the model is when the output values are corrupted with
noise. Below we compare two linear models: the first with an intercept
term, and the second without. The model with the intercept term should
be much better since the data has an intercept of <span class="math inline">\(-0.6\)</span>.</p>
<p>We see that the output is different in a few ways now. The
<code>Stat</code> column tells what the row is showing. These all say
<code>rmse</code>, meaning they are giving the root mean squared error
of the predicted values compared to the true <code>y</code>. There’s
also a new section at the bottom title <code>Compare</code>. This
compares the <code>rmse</code> values from the two methods, and does a
t-test to see if the difference is significant. However, since there is
no randomness, it fails to perform the t-test.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="dv">20</span></span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="at">length.out =</span> n)</span>
<span id="cb32-3"><a href="#cb32-3" tabindex="-1"></a>y <span class="ot">&lt;-</span> <span class="fl">1.8</span> <span class="sc">*</span> x <span class="sc">-</span> .<span class="dv">6</span></span>
<span id="cb32-4"><a href="#cb32-4" tabindex="-1"></a>ynoise <span class="ot">&lt;-</span> y <span class="sc">+</span> <span class="fu">rnorm</span>(n, <span class="dv">0</span>, .<span class="dv">2</span>)</span></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a><span class="fu">mbc</span>(<span class="fu">predict</span>(<span class="fu">lm</span>(ynoise <span class="sc">~</span> x), <span class="fu">data.frame</span>(x)),</span>
<span id="cb33-2"><a href="#cb33-2" tabindex="-1"></a>    <span class="fu">predict</span>(<span class="fu">lm</span>(ynoise <span class="sc">~</span> x <span class="sc">-</span> <span class="dv">1</span>), <span class="fu">data.frame</span>(x)),</span>
<span id="cb33-3"><a href="#cb33-3" tabindex="-1"></a>    <span class="at">target =</span> y)</span></code></pre></div>
<pre><code>## Run times (sec)
##                                     Function        Sort1        Sort2
## 1     predict(lm(ynoise ~ x), data.frame(x)) 0.0006148815 0.0006420612
## 2 predict(lm(ynoise ~ x - 1), data.frame(x)) 0.0006229877 0.0006349087
##          Sort3        Sort4        Sort5         mean           sd neval
## 1 0.0006489754 0.0006699562 0.0040249825 0.0013201714 1.512164e-03     5
## 2 0.0006380081 0.0006439686 0.0007719994 0.0006623745 6.175718e-05     5
## 
## Output summary
##                                         Func Stat         V1         V2
## 1     predict(lm(ynoise ~ x), data.frame(x)) rmse 0.03486556 0.03486556
## 2 predict(lm(ynoise ~ x - 1), data.frame(x)) rmse 0.31189957 0.31189957
##           V3         V4         V5       mean sd
## 1 0.03486556 0.03486556 0.03486556 0.03486556  0
## 2 0.31189957 0.31189957 0.31189957 0.31189957  0
## 
## Compare
##                                                                                   Func
## 1 predict(lm(ynoise ~ x), data.frame(x)) vs predict(lm(ynoise ~ x - 1), data.frame(x))
##   Stat conf.low conf.up  t  p
## 1 rmse       NA      NA NA NA</code></pre>
<p>To add randomness we can simply define <code>ynoise</code> in the
<code>inputi</code> argument, as shown below. Now there is randomness in
the data, so a paired t-test can be computed. It is paired since the
same <code>ynoise</code> is given to each model. We see that even with
only a sample size of 5, the p-value is highly significant.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" tabindex="-1"></a><span class="fu">mbc</span>(<span class="fu">predict</span>(<span class="fu">lm</span>(ynoise <span class="sc">~</span> x), <span class="fu">data.frame</span>(x)),</span>
<span id="cb35-2"><a href="#cb35-2" tabindex="-1"></a>    <span class="fu">predict</span>(<span class="fu">lm</span>(ynoise <span class="sc">~</span> x <span class="sc">-</span> <span class="dv">1</span>), <span class="fu">data.frame</span>(x)),</span>
<span id="cb35-3"><a href="#cb35-3" tabindex="-1"></a>    <span class="at">inputi=</span>{ynoise <span class="ot">&lt;-</span> y <span class="sc">+</span> <span class="fu">rnorm</span>(n, <span class="dv">0</span>, .<span class="dv">2</span>)},</span>
<span id="cb35-4"><a href="#cb35-4" tabindex="-1"></a>    <span class="at">target =</span> y)</span></code></pre></div>
<pre><code>## Run times (sec)
##                                     Function        Sort1        Sort2
## 1     predict(lm(ynoise ~ x), data.frame(x)) 0.0006039143 0.0006308556
## 2 predict(lm(ynoise ~ x - 1), data.frame(x)) 0.0005760193 0.0006251335
##          Sort3        Sort4        Sort5         mean          sd neval
## 1 0.0006418228 0.0006690025 0.0009450912 0.0006981373 0.000140010     5
## 2 0.0006289482 0.0006670952 0.0029590130 0.0010912418 0.001044617     5
## 
## Output summary
##                                         Func Stat         V1         V2
## 1     predict(lm(ynoise ~ x), data.frame(x)) rmse 0.04772297 0.04205276
## 2 predict(lm(ynoise ~ x - 1), data.frame(x)) rmse 0.31425846 0.31135820
##           V3         V4         V5       mean          sd
## 1 0.04900406 0.08436103 0.02185191 0.04899855 0.022568322
## 2 0.31485779 0.31178120 0.31209022 0.31286917 0.001577832
## 
## Compare
##                                                                                Func
## t predict(lm(ynoise ~ x), data.frame(x))-predict(lm(ynoise ~ x - 1), data.frame(x))
##   Stat         V1         V2         V3         V4         V5       mean
## t rmse -0.2665355 -0.2693054 -0.2658537 -0.2274202 -0.2902383 -0.2638706
##           sd         t            p
## t 0.02271818 -25.97183 1.305753e-05</code></pre>
</div>
<div id="simplifying-with-evaluator" class="section level2">
<h2>Simplifying with <code>evaluator</code></h2>
<p>Many times the code chunks we want to compare only differ by a small
amount, such as a single argument. In the example above, the only
difference is the formula in the <code>lm</code> command. With
<code>mbc</code>, the <code>evaluator</code> can be set to make these
cases easier. The argument for <code>evaluator</code> should be an
expression including <code>.</code>, which will be replaced with the
code chunks provided. The example below rewrites the above comparison
using <code>evaluator</code>.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" tabindex="-1"></a><span class="fu">mbc</span>(ynoise <span class="sc">~</span> x,</span>
<span id="cb37-2"><a href="#cb37-2" tabindex="-1"></a>    ynoise <span class="sc">~</span> x <span class="sc">-</span> <span class="dv">1</span>,</span>
<span id="cb37-3"><a href="#cb37-3" tabindex="-1"></a>    <span class="at">evaluator=</span><span class="fu">predict</span>(<span class="fu">lm</span>(.), <span class="fu">data.frame</span>(x)),</span>
<span id="cb37-4"><a href="#cb37-4" tabindex="-1"></a>    <span class="at">inputi=</span>{ynoise <span class="ot">&lt;-</span> y <span class="sc">+</span> <span class="fu">rnorm</span>(n, <span class="dv">0</span>, .<span class="dv">2</span>)},</span>
<span id="cb37-5"><a href="#cb37-5" tabindex="-1"></a>    <span class="at">target =</span> y)</span></code></pre></div>
<pre><code>## Run times (sec)
##         Function        Sort1        Sort2        Sort3        Sort4
## 1     ynoise ~ x 0.0005779266 0.0005910397 0.0006289482 0.0006480217
## 2 ynoise ~ x - 1 0.0005629063 0.0005860329 0.0005991459 0.0006051064
##          Sort5         mean           sd neval
## 1 0.0011458397 0.0007183552 2.406309e-04     5
## 2 0.0007331371 0.0006172657 6.676976e-05     5
## 
## Output summary
##             Func Stat         V1         V2         V3         V4         V5
## 1     ynoise ~ x rmse 0.03486556 0.03486556 0.03486556 0.03486556 0.03486556
## 2 ynoise ~ x - 1 rmse 0.31189957 0.31189957 0.31189957 0.31189957 0.31189957
##         mean sd
## 1 0.03486556  0
## 2 0.31189957  0
## 
## Compare
##                        Func Stat        V1        V2        V3        V4
## 1 ynoise ~ x-ynoise ~ x - 1 rmse -0.277034 -0.277034 -0.277034 -0.277034
##          V5      mean sd  t  p
## 1 -0.277034 -0.277034  0 NA NA</code></pre>
</div>
<div id="k-fold-cross-validation" class="section level2">
<h2>K-Fold Cross Validation</h2>
<p>K-fold cross validation can also be done using <code>mbc</code> using
the <code>kfold</code> parameter. K-fold cross validation involves
splitting <span class="math inline">\(N\)</span> data points into <span class="math inline">\(k\)</span> groups. <code>kfold</code> should
specify what this <span class="math inline">\(N\)</span> is, since it
depends on the data. By default it will set the number of folds, <span class="math inline">\(k\)</span>, to be <code>times</code>. Then each
replicate will be evaluating a single fold. Note that this will not do
<span class="math inline">\(k\)</span> folds <span class="math inline">\(times\)</span> times.</p>
<p>To make <span class="math inline">\(k\)</span> different from <span class="math inline">\(times\)</span>, pass in <span class="math inline">\(kfold\)</span> as a vector whose second element in
the number of folds. For example, suppose you have 100 data points, want
to do 5 folds, and repeat this process twice (i.e. evaluate 10 folds).
Then you should pass in <span class="math inline">\(kfold=c(100,5)\)</span> and <span class="math inline">\(times=10\)</span>. The first five trials would
then the the five separate folds. The sixth through tenth trials would
be a new partition of the data into five folds.</p>
<p>Then to use this folds you must use <code>ki</code> as part of an
expression in the code chunk or <code>inputi</code>. The following shows
how to use k-fold cross validation fitting a linear model to the
<code>cars</code> dataset. Setting <code>kfold=c(nrow(cars), 5)</code>
tells it that you want to use 5 folds on the <code>cars</code> data set.
It has 50 rows, so in each trial <code>ki</code> is a subset of
<code>1:50</code> of 40 elements. Setting <code>times=30</code> means
that we are repeating the five folds six times. The code chunk fits the
model, makes predictions on the hold-out data, and calculates the
RMSE.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" tabindex="-1"></a><span class="fu">mbc</span>({mod <span class="ot">&lt;-</span> <span class="fu">lm</span>(dist <span class="sc">~</span> speed, <span class="at">data=</span>cars[ki,])</span>
<span id="cb39-2"><a href="#cb39-2" tabindex="-1"></a>     p <span class="ot">&lt;-</span> <span class="fu">predict</span>(mod,cars[<span class="sc">-</span>ki,])</span>
<span id="cb39-3"><a href="#cb39-3" tabindex="-1"></a>     <span class="fu">sqrt</span>(<span class="fu">mean</span>((p <span class="sc">-</span> cars<span class="sc">$</span>dist[<span class="sc">-</span>ki])<span class="sc">^</span><span class="dv">2</span>))</span>
<span id="cb39-4"><a href="#cb39-4" tabindex="-1"></a>     },</span>
<span id="cb39-5"><a href="#cb39-5" tabindex="-1"></a>    <span class="at">kfold=</span><span class="fu">c</span>(<span class="fu">nrow</span>(cars), <span class="dv">5</span>),</span>
<span id="cb39-6"><a href="#cb39-6" tabindex="-1"></a>    <span class="at">times=</span><span class="dv">30</span>)</span></code></pre></div>
<pre><code>## Run times (sec)
##                                                                                                           Function
## 1 { mod &lt;- lm(dist ~ speed, data = cars[ki, ]) p &lt;- predict(mod, cars[-ki, ]) sqrt(mean((p - cars$dist[-ki])^2)) }
##           Min.      1st Qu.       Median         Mean      3rd Qu.        Max.
## 1 0.0005500317 0.0005877614 0.0006076097 0.0006978591 0.0006324649 0.002804041
##            sd neval
## 1 0.000403711    30
## 
## Output summary
##                                                                                                               Func
## 1 { mod &lt;- lm(dist ~ speed, data = cars[ki, ]) p &lt;- predict(mod, cars[-ki, ]) sqrt(mean((p - cars$dist[-ki])^2)) }
##   Stat     Min.  1st Qu.   Median     Mean  3rd Qu.     Max.       sd
## 1    1 8.929092 11.72902 13.85972 15.19293 19.13354 23.79548 4.322134</code></pre>
<p>The following example simplifies this a little. Setting
<code>targetin</code> tells it what the input to <code>predict</code>
should be and setting <code>target=&quot;dist&quot;</code> tells it that the
target is the <code>dist</code> element from <code>targetin</code>. You
cannot set <code>target=cars$dit[-ki]</code> since <code>target</code>
cannot be evaluated as an expression.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" tabindex="-1"></a><span class="fu">mbc</span>(<span class="fu">lm</span>(dist <span class="sc">~</span> speed, <span class="at">data=</span>cars[ki,]),</span>
<span id="cb41-2"><a href="#cb41-2" tabindex="-1"></a>    <span class="at">targetin=</span>cars[<span class="sc">-</span>ki,], <span class="at">target=</span><span class="st">&quot;dist&quot;</span>,</span>
<span id="cb41-3"><a href="#cb41-3" tabindex="-1"></a>    <span class="at">kfold=</span><span class="fu">c</span>(<span class="fu">nrow</span>(cars), <span class="dv">5</span>),</span>
<span id="cb41-4"><a href="#cb41-4" tabindex="-1"></a>    <span class="at">times=</span><span class="dv">30</span>)</span></code></pre></div>
<pre><code>## Run times (sec)
##                              Function         Min.      1st Qu.       Median
## 1 lm(dist ~ speed, data = cars[ki, ]) 0.0003139973 0.0003354549 0.0003554821
##           Mean      3rd Qu.        Max.           sd neval
## 1 0.0003877401 0.0003721118 0.001163006 0.0001516688    30
## 
## Output summary
##                                  Func Stat     Min.  1st Qu.  Median     Mean
## 1 lm(dist ~ speed, data = cars[ki, ]) rmse 10.51727 11.74167 14.4834 15.48358
##    3rd Qu.     Max.       sd
## 1 18.85401 24.05299 4.106909</code></pre>
</div>
<div id="metrics" class="section level2">
<h2>Metrics</h2>
<p>In the previous example, the output shows that the “Stat” is “rmse”,
meaning that it calculated the root-mean-square error from the.
predictions and target values. The metric, or statistic, calculated can
be changed using the <code>metric</code> argument, which defaults to
<code>rmse</code>. Three of the other options for <code>metric</code>
are <code>t</code>, <code>mis90</code>, and <code>sr27</code>. These
three all compare target values (<span class="math inline">\(y\)</span>)
to predicted values (<span class="math inline">\(\hat{y}\)</span>) and
predicted errors (<span class="math inline">\(s\)</span>). These only
work for models that give predicted errors, such as Gaussian process
models.</p>
<div id="metrict" class="section level3">
<h3><code>metric=t</code></h3>
<p>Using these the target value, predicted value, and predicted error,
we can calculate a t-score.</p>
<p><span class="math display">\[ t = \frac{\hat{y} - y}{s} \]</span></p>
<p>The output then shows the distribution of these t-scores by showing
the six number summary.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" tabindex="-1"></a><span class="fu">mbc</span>(<span class="fu">lm</span>(dist <span class="sc">~</span> speed, <span class="at">data=</span>cars[ki,]),</span>
<span id="cb43-2"><a href="#cb43-2" tabindex="-1"></a>    <span class="at">targetin=</span>cars[<span class="sc">-</span>ki,], <span class="at">target=</span><span class="st">&quot;dist&quot;</span>,</span>
<span id="cb43-3"><a href="#cb43-3" tabindex="-1"></a>    <span class="at">kfold=</span><span class="fu">c</span>(<span class="fu">nrow</span>(cars), <span class="dv">5</span>),</span>
<span id="cb43-4"><a href="#cb43-4" tabindex="-1"></a>    <span class="at">times=</span><span class="dv">30</span>,</span>
<span id="cb43-5"><a href="#cb43-5" tabindex="-1"></a>    <span class="at">metric=</span><span class="st">&#39;t&#39;</span>)</span></code></pre></div>
<pre><code>## Run times (sec)
##                              Function         Min.      1st Qu.       Median
## 1 lm(dist ~ speed, data = cars[ki, ]) 0.0003368855 0.0003628731 0.0004019737
##           Mean      3rd Qu.         Max.           sd neval
## 1 0.0004223347 0.0004310012 0.0008871555 0.0001087221    30
## 
## Output summary
##                                  Func      Stat        Min.     1st Qu.
## 1 lm(dist ~ speed, data = cars[ki, ])    Min. t -20.9075400 -11.5984276
## 2 lm(dist ~ speed, data = cars[ki, ]) 1st Qu. t  -4.9313685  -2.7018594
## 3 lm(dist ~ speed, data = cars[ki, ])  Median t  -2.8354889  -0.4966254
## 4 lm(dist ~ speed, data = cars[ki, ])    Mean t  -3.2792170  -0.7899931
## 5 lm(dist ~ speed, data = cars[ki, ]) 3rd Qu. t   0.4225208   1.6802855
## 6 lm(dist ~ speed, data = cars[ki, ])    Max. t   3.3310282   6.0047720
##       Median       Mean    3rd Qu.        Max.       sd
## 1 -9.7004842 -9.8979129 -7.8246452 -0.08528217 5.402287
## 2 -2.0802868 -1.8818658 -0.8568723  1.61930520 1.752299
## 3  0.6155601  0.7373985  1.9882930  3.95020736 1.803065
## 4  0.3880399  0.1253952  0.9522826  3.31685915 1.650908
## 5  2.8136150  2.9367746  3.9946167  6.06310737 1.536431
## 6  7.1397249  7.0871224  8.8368563  9.65604663 1.942429</code></pre>
</div>
<div id="metricmis90" class="section level3">
<h3><code>metric=mis90</code></h3>
<p>The t-score metric is not very informative because you can get the
same t-scores by having a large error and large predicted error as
having a small error and small predicted error. <code>mis90</code> is
the mean interval score for 90% coverage intervals as described by <span class="citation">Gneiting and Raftery (2007, Equation 43)</span>.</p>
<p><span class="math display">\[ 3.28s + 20 \left( \hat{y} - y - 1.64s
\right)^+ + 20 \left( y - \hat{y} - 1.64s \right)^+  \]</span> where
<span class="math inline">\(()^+\)</span> denotes the positive part of
what is in the parentheses. Smaller values are better. This metric
penalizes having large predicted errors and having actual errors
different from the predicted errors, so it is very good for judging the
accuracy of a prediction interval.</p>
</div>
<div id="metricsr27" class="section level3">
<h3><code>metric=sr27</code></h3>
<p>The scoring rule in Equation 27 <span class="citation">Gneiting and
Raftery (2007)</span> is another proper scoring rule.</p>
<p><span class="math display">\[  -\left( \frac{\hat{y} - y}{s}
\right)^2 - \log s^2 \]</span> For this metric, larger values are
better. A problem with this metric is that if <span class="math inline">\(s=0\)</span>, which can happen from numerical
issues, then it will go to infinity, which does not happen with the mean
interval score.</p>
</div>
</div>
<div id="running-time-consuming-experiments-with-ffexp" class="section level2">
<h2>Running time-consuming experiments with <code>ffexp</code></h2>
<p>The other main function of the package is <code>ffexp</code>, an
abbreviation for full-factorial experiment. It will run a function using
all possible combinations of input parameters given. It is useful for
running experiments that take a long time to complete.</p>
<p>The first arguments given to <code>ffexp$new</code> should give the
possible values for each input parameter. In the example below,
<code>a</code> can be 1, 2, or 3, and <code>b</code> can “a”, “b”, or
“c”. Then <code>eval_func</code> should be given that can operate on
these parameters. For example, using <code>eval_func = paste</code> will
paste together the value of <code>a</code> with the value of
<code>b</code>.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" tabindex="-1"></a>f1 <span class="ot">&lt;-</span> ffexp<span class="sc">$</span><span class="fu">new</span>(</span>
<span id="cb45-2"><a href="#cb45-2" tabindex="-1"></a>  <span class="at">a=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>,</span>
<span id="cb45-3"><a href="#cb45-3" tabindex="-1"></a>  <span class="at">b=</span><span class="fu">c</span>(<span class="st">&quot;a&quot;</span>,<span class="st">&quot;b&quot;</span>,<span class="st">&quot;c&quot;</span>),</span>
<span id="cb45-4"><a href="#cb45-4" tabindex="-1"></a>  <span class="at">eval_func=</span>paste</span>
<span id="cb45-5"><a href="#cb45-5" tabindex="-1"></a>)</span></code></pre></div>
<p>After creating the <code>ffexp</code> object, we can call
<code>f1$run_all</code> to run <code>eval_func</code> on every
combination of <code>a</code> and <code>b</code>.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a>f1<span class="sc">$</span><span class="fu">run_all</span>()</span></code></pre></div>
<p>Now to see the results in a clean format, look at
<code>f1$outcleandf</code>.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" tabindex="-1"></a>f1<span class="sc">$</span>outcleandf</span></code></pre></div>
<pre><code>##   a b  V1 runtime          start_time            end_time run_number
## 1 1 a 1 a       0 2024-09-29 12:53:37 2024-09-29 12:53:37          1
## 2 2 a 2 a       0 2024-09-29 12:53:37 2024-09-29 12:53:37          2
## 3 3 a 3 a       0 2024-09-29 12:53:37 2024-09-29 12:53:37          3
## 4 1 b 1 b       0 2024-09-29 12:53:37 2024-09-29 12:53:37          4
## 5 2 b 2 b       0 2024-09-29 12:53:37 2024-09-29 12:53:37          5
## 6 3 b 3 b       0 2024-09-29 12:53:37 2024-09-29 12:53:37          6
## 7 1 c 1 c       0 2024-09-29 12:53:37 2024-09-29 12:53:37          7
## 8 2 c 2 c       0 2024-09-29 12:53:37 2024-09-29 12:53:37          8
## 9 3 c 3 c       0 2024-09-29 12:53:37 2024-09-29 12:53:37          9</code></pre>
</div>
<div id="references" class="section level2 unnumbered">
<h2 class="unnumbered">References</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-gneiting" class="csl-entry">
Gneiting, Tilmann, and Adrian E. Raftery. 2007. <span>“Strictly Proper
Scoring Rules, Prediction, and Estimation.”</span> <em>Journal of the
American Statistical Association</em>, 359–78.
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
